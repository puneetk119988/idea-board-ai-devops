name: AI DevOps CI/CD

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy (staging|prod|preview)"
        required: true
        default: "prod"
      goal:
        description: "High-level goal (cost|balanced|ha)"
        required: true
        default: "balanced"
      preview_name:
        description: "Preview name (only used if environment=preview)"
        required: false
        default: ""
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: read
  pull-requests: read

jobs:
  decide:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.parse.outputs.should_run }}
      environment: ${{ steps.parse.outputs.environment }}
      goal: ${{ steps.parse.outputs.goal }}
      preview_name: ${{ steps.parse.outputs.preview_name }}
    steps:
      - name: Parse trigger
        id: parse
        shell: bash
        run: |
          set -euo pipefail

          # Defaults for push/main
          ENVIRONMENT="prod"
          GOAL="balanced"
          PREVIEW_NAME=""

          SHOULD_RUN="false"

          if [[ "${{ github.event_name }}" == "push" ]]; then
            SHOULD_RUN="true"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            SHOULD_RUN="true"
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            GOAL="${{ github.event.inputs.goal }}"
            PREVIEW_NAME="${{ github.event.inputs.preview_name }}"
          elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            BODY="${{ github.event.comment.body }}"
            # Supported:
            # /deploy prod goal=ha
            # /deploy staging goal=cost
            # /deploy-preview feature-x goal=cost
            if echo "$BODY" | grep -qE '^/deploy(\s|$)'; then
              SHOULD_RUN="true"
              ENVIRONMENT="$(echo "$BODY" | awk '{print $2}' | tr -d '\r' || true)"
              [[ -z "$ENVIRONMENT" ]] && ENVIRONMENT="prod"
              GOAL="$(echo "$BODY" | sed -n 's/.*goal=\([a-zA-Z0-9_-]*\).*/\1/p' | head -n1 || true)"
              [[ -z "$GOAL" ]] && GOAL="balanced"
            elif echo "$BODY" | grep -qE '^/deploy-preview(\s|$)'; then
              SHOULD_RUN="true"
              ENVIRONMENT="preview"
              PREVIEW_NAME="$(echo "$BODY" | awk '{print $2}' | tr -d '\r' || true)"
              [[ -z "$PREVIEW_NAME" ]] && PREVIEW_NAME="preview"
              GOAL="$(echo "$BODY" | sed -n 's/.*goal=\([a-zA-Z0-9_-]*\).*/\1/p' | head -n1 || true)"
              [[ -z "$GOAL" ]] && GOAL="cost"
            fi
          fi

          echo "should_run=$SHOULD_RUN" >> "$GITHUB_OUTPUT"
          echo "environment=$ENVIRONMENT" >> "$GITHUB_OUTPUT"
          echo "goal=$GOAL" >> "$GITHUB_OUTPUT"
          echo "preview_name=$PREVIEW_NAME" >> "$GITHUB_OUTPUT"

  deploy:
    needs: decide
    if: needs.decide.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ENVIRONMENT: ${{ needs.decide.outputs.environment }}
      GOAL: ${{ needs.decide.outputs.goal }}
      PREVIEW_NAME: ${{ needs.decide.outputs.preview_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS + kubectl (EKS)
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail

          if [[ -z "${AWS_ACCESS_KEY_ID}" || -z "${AWS_SECRET_ACCESS_KEY}" || -z "${AWS_REGION}" ]]; then
            echo "Missing AWS secrets (AWS_ACCESS_KEY_ID / AWS_SECRET_ACCESS_KEY / AWS_REGION)."
            exit 1
          fi

          if [[ -z "${{ secrets.KUBECONFIG_B64 }}" ]]; then
            echo "Missing secret KUBECONFIG_B64."
            exit 1
          fi

          echo "${{ secrets.KUBECONFIG_B64 }}" | base64 -d > kubeconfig
          export KUBECONFIG="$PWD/kubeconfig"

          aws --version
          kubectl version --client
          kubectl get nodes

      - name: AI suggests deployment settings (replicas)
        id: suggest
        shell: bash
        run: |
          set -euo pipefail
          python .github/scripts/ai_suggest_config.py "$ENVIRONMENT" "$GOAL" > suggested.env
          cat suggested.env >> "$GITHUB_STEP_SUMMARY"
          source suggested.env
          echo "backend_replicas=${BACKEND_REPLICAS}" >> "$GITHUB_OUTPUT"
          echo "frontend_replicas=${FRONTEND_REPLICAS}" >> "$GITHUB_OUTPUT"

      - name: Apply replicas (patch)
        shell: bash
        run: |
          set -euo pipefail
          export KUBECONFIG="$PWD/kubeconfig"
          kubectl -n idea-board scale deploy/backend --replicas=${{ steps.suggest.outputs.backend_replicas }} || true
          kubectl -n idea-board scale deploy/frontend --replicas=${{ steps.suggest.outputs.frontend_replicas }} || true

      - name: AI generates safe kubectl plan
        shell: bash
        run: |
          set -euo pipefail
          python .github/scripts/ai_plan.py "$ENVIRONMENT" > /tmp/deploy_plan.sh
          echo "### AI Deployment Plan" >> "$GITHUB_STEP_SUMMARY"
          echo '```bash' >> "$GITHUB_STEP_SUMMARY"
          sed 's/OPENAI_API_KEY=.*/OPENAI_API_KEY=***redacted***/g' /tmp/deploy_plan.sh >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - name: Execute deployment plan
        shell: bash
        run: |
          set -euo pipefail
          export KUBECONFIG="$PWD/kubeconfig"
          bash /tmp/deploy_plan.sh

      - name: Wait for rollout
        shell: bash
        run: |
          set -euo pipefail
          export KUBECONFIG="$PWD/kubeconfig"
          kubectl -n idea-board rollout status deploy/backend --timeout=180s
          kubectl -n idea-board rollout status deploy/frontend --timeout=180s

      - name: AI health check (logs + optional rollback)
        shell: bash
        run: |
          set -euo pipefail
          export KUBECONFIG="$PWD/kubeconfig"
          python .github/scripts/ai_healthcheck.py